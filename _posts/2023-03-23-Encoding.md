---
layout: post
title:  "Octetos y codificaci√≥n de caracteres"
date:   2023-03-10 14:46:44 +0100
categories: c√≥digos codificaci√≥n 
author: "by rnek0"
lang: "es"
permalink: "/encoding/"
---

üá™üá∏ Como comprender y saber si ando con little endian ?

Este texto se puede leer en franc√©s en mi capsula [Gemini](gemini://gmi.lunarviews.net) en IPV6 o pasando por [Gemini portal](https://portal.mozz.us/gemini/gmi.lunarviews.net/index.gmi)

Se trata de conocer poco a poco diferentes conceptos sobre numeraci√≥n y codificaci√≥n antes de ir mas tarde a por cosas en assembler (asm) o reverse.

Para probar que estoy en little endian me servir√© de Unicode, os advierto que si no sab√©is de que hablo, voy a intentar de aliviaros la cosa para que os sent√°is mas c√≥modo con los ordenadores.

Venga, para empezar este post nos serviremos del valor de la e√±e , el cual es el siguiente en Unicode __\u00f1__

Un ejemplo con este comando en bash que produce la salida Hacker√±ol

```bash
echo -e "Hacker\u00f1ol\n"
Hacker√±ol

```

Todos conocemos (o casi) el comando echo, el argumento -e permite de evitar de interpretar los caracteres d'escape ( los que empiezan por una barra invertida __\\__ ), que es el terminal ? Es una manera de dar ordenes a tu ordenador, (antiguamente no hab√≠a interfaces gr√°ficas con ventanas y rat√≥n); usando comandos puedes dialogar con el ordenador, el comando **echo** hace una salida por pantalla de texto. Se puede pues insertar en la cadena de texto este valor **\u00f1** que es el correspondiente en el punto de c√≥digo Unicode de la letra __√±__

&nbsp;

## Que es Unicode ?

Un ordenador solo comprende una serie de cifras, no conoce ning√∫n idioma. Ni en ingles, ni el franc√©s ni tampoco el chino.

La √∫nicas cifras que el ordenador comprende son el uno y el zero ( 0 ou 1 ). De hecho interiormente tampoco conoce esas cifras, digamos mejor que sabe hacer la diferencia entre dos estados en sus circuitos. La corriente el√©ctrica pasa o no pasa. Por comodidad se escogi√≥ el decir que si la corriente pasa, sera el 1, en cambio si la corriente no pasa se dir√° que es el cero. El caso contrario tambi√©n es cierto, se podr√≠a haber dicho lo contrario, es una convenci√≥n. Lo cierto es que solo disponemos de dos estados; mas tarde veremos que un bit (la unidad minima de informaci√≥n) tiene dos estados. Se quiso pues que algo que se parec√≠a a una bombilla de luz pudiera servir a hacer c√°lculos, o est√° en un estado encendi√≥ o en un estado apagado. Y un dia un hombre genial invento (o descubri√≥) los n√∫meros binarios... 

Si pero eso no responde a la pregunta, pues **Unicode** √©s una representaci√≥n codificada de los caracteres que pueden ser utilizados por todos los idiomas, lo vamos a ver un poco mas tarde (su inter√©s y utilizaci√≥n)

&nbsp;

## ¬øSabes contar?

Los humanos disponemos de dos manos, si claro, y en general con 5 dedos cada una. Por ello es posible que se escogi√≥ la base 10 (numero de dedos) comme base de calculo. As√≠ que nuestra forma cl√°sica de hacer las cuentas se basa en un sistema decimal, solo se usan 10 d√≠gitos o cifras para representar un n√∫mero. Nuestro amigo el ordenador no tiene dedos y no entiende nada m√°s que el idioma de la bombilla (encendida o apagada). Tiene por tanto una base de c√°lculo de dos estados (ya sea 1 o 0) por lo que esta base se denominar√° binaria.

Entonces, nosotros usamos __decimal__ y la computadora usa __binario__.

Vamos, empecemos a contar: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 (estas son nuestras cifras), pero para ir m√°s all√° del 9, ya que solo tenemos estos 10 d√≠gitos, pues sumaremos 1 a la izquierda y a la derecha volvemos a nuestro d√≠gito inicial (el 0). Esto da 10, estamos acostumbrados a hacerlo y nos parece normal. Si llegamos a 19 sumamos 1 a la izquierda y por lo tanto continuamos con el 20, tenemos las cifras para eso, pero ¬øqu√© hacemos cuando lleguemos a 99 ? Lo mismo que cuando llegamos al 9, sumamos 1 a la izquierda y ponemos el 9 a cero. Cada vez que sumamos una columna y por lo tanto al multiplicar el n√∫mero de la columna por la base (10), entonces la suma de todas las columnas, nos da el n√∫mero que queremos expresar.La primera columna tiene un valor de 0 para la base porque a√∫n no hemos agregado ninguna columna. Entonces, para tomar un ejemplo simple (con el n√∫mero 150) :  

```bash
150 = 1 x 10¬≤ + 5 x 10¬π + 0 x 10‚Å∞
```

Para los curiosos: ¬øc√≥mo se escribe esto de aqu√≠ arriba con un poco de Unicode y el comando echo?

```bash
echo -e "150 = 1 x 10\u00b2 + 5 x 10\u00b9 + 0 x 10\u2070"
```

Ahora le toca el turno a nuestro amigo el ordenador. 0, 1 (estas son sus cifras), entonces, ¬øqu√© hace cuando llega al 1? Pues s√≠, como nosotros, agrega una columna a la izquierda con un 1 y vuelve a colocar la primera columna en 0. Seguimos la misma l√≥gica que con la base d√©cimal; el orden de las columnas nos da el n√∫mero a poner en potencia de su base (aqu√≠ sera **2**), luego sumamos los resultados de cada columna. 

Ejemplo (en base 2) 1101

1 + 2¬≥ + 1 x 2¬≤ + 0 x 2¬π + 1 x 2‚Å∞  
= 8 + 4 + 0 + 1  
= 13  

Un poco m√°s de Unicode ;)

```bash
echo -e "1 + 2\u00b3 + 1 x 2\u00b2 + 0 x 2\u00b9 + 1 x 2\u2070"
1 + 2¬≥ + 1 x 2¬≤ + 0 x 2¬π + 1 x 2‚Å∞
```

Compararemos contando con la computadora para ver (a la izquierda somos nosotros en decimal, a la derecha la computadora en binario):  

0  -> 0  
1  -> 1  
2  -> 10  
3  -> 11  
4  -> 100  
5  -> 101  
6  -> 110  
7  -> 111  
8  -> 1000  
9  -> 1001  

10 -> 1010  
11 -> 1011  
12 -> 1100  
13 -> 1101  
14 -> 1110  
15 -> 1111  
... etc ...  

Vale eso es genial, descubrimos __c√≥mo cuenta una computadora \o/__

&nbsp;

## ¬øSabes escribir?

Los humanos tenemos letras adem√°s de n√∫meros, as√≠ que podemos escribir cosas como este texto que est√°s leyendo. Nuestro amigo el ordenador no tiene letras, entonces ¬øc√≥mo lo hace?  
Bueno, para eso inventamos convenciones que hacen que ciertos n√∫meros en la computadora siempre se correspondan con ciertas letras o caracteres. Esto se ha llamado "[codificaci√≥n de caracteres](https://es.wikipedia.org/wiki/Codificaci%C3%B3n_de_caracteres)". Los primeros no eran compatibles entre s√≠ pero finalmente encontramos un est√°ndar: este fu√© el c√≥digo [ASCII](https://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange).  

El c√≥digo ASCII es el antepasado del famoso [__Unicode__](https://es.wikipedia.org/wiki/Unicode) del que hablo al principio de este texto, por ejemplo la letra √± no existe en ASCII pero si en Unicode.

En pocas palabras, diremos que la memoria de la computadora se compone de filas que tienen 8 ranuras cada una. 8 bombillas por fila, por lo tanto 8 d√≠gitos binarios que pueden ser 0 o 1 y que se llaman bits. Usamos 7 bits para codificar los caracteres, y por lo tanto, por ejemplo, el c√≥digo binario __0100 0001__ siempre representar√° la letra A en c√≥digo ASCII. Y el octavo ? pues sirve para hacer verificaciones de errores de transmisi√≥n. 

Este c√≥digo, a pesar de haber sido un est√°ndar, no fue lo suficientemente evolucionado para tener en cuenta todos los caracteres de todos los idiomas del planeta tierra. Hab√≠a c√≥digos adicionales para completar el c√≥digo ASCII, por ejemplo para tener letras acentuadas u otros caracteres que no se hab√≠an previsto. Pero empezamos a tener incompatibilidades de codificaci√≥n entre estos c√≥digos.

Hoy en d√≠a, esta codificaci√≥n ha evolucionado, el est√°ndar actual es Unicode. Unicode incluye ASCII, lo que significa que se respetan los primeros c√≥digos ASCII, pero como Unicode tiene m√°s c√≥digos (porque hay m√°s caracteres para cifrar) ocupa m√°s espacio en la memoria de la computadora. Por poner un ejemplo si tomamos __UTF-8__ que es una de las tres posibilidades reconocidas por Unicode y pr√°cticamente generalizadas en todo el planeta, las posiciones de memoria requeridas para codificar los caracteres van de 1 a 4 bytes (es decir de 8 a 32 bit ).
Para los curiosos, UTF-8 fue creado por Robert C. Pike y Kenneth L. Thompson. El primero tambi√©n cre√≥ el lenguaje Go y el segundo es considerado uno de los padres de UNIX con el Sr. Dennis Ritchie quien fue el creador del lenguaje C. 

&nbsp;

## ¬øSabes c√≥mo ordenar?

Ahora sabemos que el lenguaje de las computadoras es binario, es el c√≥digo de m√°quina que el procesador procesar√° cuando ejecute un programa de computadora. Es una serie de bits que componen instrucciones para el procesador y cada familia de procesadores tiene la suya. Estas instrucciones son √∫nicas con funcionalidades bien definidas, cuando ha terminado de ejecutar una instrucci√≥n pasa a la siguiente. Pero para poder decirle a la computadora qu√© hacer, los humanos no podemos perder nuestro tiempo contando y escribiendo secuencias interminables de 0 y 1. Por lo tanto, debemos encontrar una manera de ordenar las instrucciones de tal manera que podamos reconocerlas y que podamos ponernos de acuerdo con la computadora para decirle qu√© hacer.

Entonces comenzamos dando nombres simples a estas instrucciones que el procesador sabe c√≥mo procesar. Por ejemplo, el procesador cuando encuentra esto: __10110000 01100001__ __reconocer√°__ la instrucci√≥n a ejecutar. Por lo tanto, hemos asignado nombres significativos para los humanos a este tipo de instrucciones que llamamos __mnemot√©cnicos__, por lo que la instrucci√≥n anterior se convierte en esta (en un lenguaje m√°s comprensible para nosotros):
  
```asm
movb $0x61,%ali
```

Por otro lado, podemos ver claramente que los bits est√°n por lo tanto separados en grupos de 8 bits (bytes), esto ya es una primera puesta en orden (o arreglo). Podemos ver que no es muy f√°cil interpretar esto a primera vista, as√≠ que usaremos otra forma de contar para visualizar mejor la cosa. Y ah√≠, para poner m√°s orden, pasaremos por un sistema digital en **base 16** en lugar del binario que ya hemos visto (en base 2). ¬øC√≥mo es esto posible? bien diremos que los n√∫meros que definen los 16 elementos ir√°n del 0 al 9 como en decimal, pero como necesitamos otros y que deben ser diferentes a los anteriores los simbolizaremos con letras que van de la A a la F. Esto proporciona lo que serian estos d√≠gitos o cifras (si se les puede llamar asi ): 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F

C√≥mo lo hacemos entonces ? Contamos de la misma forma que con las dem√°s bases, de 0 a F y llegados a F ponemos una segunda columna a la izquierda y ponemos a cero a la derecha ;)

A esto se le llamara numeraci√≥n **hexadecimal**. 

Ejemplo con el n√∫mero __2BD__ (en hexadecimal):

Aqu√≠ representaremos las potencias como en un lenguaje llamado Python, es decir que (16**2) es equivalente a 16¬≤, quiz√°s tenga m√°s sentido:
  
```Python
2BD = 2 √ó (16 ** 2) + 11 √ó (16 ** 1) + 13 √ó (16 ** 0)
512 + 176 + 13
701
```

Entonces, para simplificar, dado que (255) en base 10 es igual a (FF) en base 16 y, de hecho, con dos d√≠gitos en base 16 es lo mismo que 8 bits en binario \o/. O que una columna en hexadecimal representara hasta 4 bits.

En otras palabras: dado que un byte puede tomar 256 valores (es decir, 2^8), podemos describir cada byte con dos d√≠gitos hexadecimales.

¬°Es mejor leer FF que 11111111! ¬øNo es cierto ?

Por lo tanto, ordenaremos nuestros bytes en pares de n√∫meros hexadecimales, para que sea m√°s visible. Pregunta: ¬øNotaste esto (__$0x61__) en varias l√≠neas arriba con el codigo assembler?

&nbsp;

## Finalmente llegamos a little endian

Eso est√° muy bien, pero... ¬øqu√© tiene que ver con [little endian](https://es.wikipedia.org/wiki/Endianness)?

Hablamos de instrucciones un poco m√°s arriba y del hecho de que cada procesador tiene las suyas. Como todas est√°n en binario, debe haber un tama√±o determinado para que el procesador las identifique (no todos los procesadores tienen el mismo tama√±o de procesamiento) Bueno, este tama√±o es lo que se llama **"un word"** (una [palabra](https://es.wikipedia.org/wiki/Palabra_(inform%C3%A1tica)) en ingl√©s), estamos hablando de procesadores de 8, 16, 32 o 64 bits pero hay otros.

Existen por tanto dos tendencias para saber __en qu√© sentido se escriben los words__ para ser procesadas en las diferentes memorias de la computadora, little endianness o big endianness, "En inform√°tica, endianness es el orden o secuencia de bytes de una palabra de datos digitales en memoria de la computadora. 

Aqu√≠ est√° nuestro ejemplo: vamos a escribir la palabra Hacker√±ol en la pantalla, pero tenemos un teclado franc√©s...

1) primer intento:

```bash
echo "Hackernol"
```

no tenemos la tecla correcta, entonces nos decimos que el car√°cter existe y que debe estar en la tabla Unicode, lo buscamos y nos encontramos con el mencionado anteriormente en el art√≠culo ( \\u00f1 )

2) Segundo intento, usamos Unicode (de 1 a 4 bytes)

```
echo -e "Hacker\u00f1ol\n"
Hacker√±ol
```

Obtenemos un buen resultado en pantalla, pero a√∫n no sabemos si estamos en little endian o no.

3) Tercer intento

Ahora echemos un vistazo m√°s profundo con un programa llamado **hexdump**


```bash
‚ùØ printf "Hacker\u00f1ol\n" | hexdump
0000000 6148 6b63 7265 b1c3 6c6f 000a          
000000b
```

Empezamos a ver c√≥digo hexadecimal :)  
Pero, ¬øqu√© significa este c√≥digo? ¬øSi tratamos de convertirlo a Unicode?

Vamos a ello ! empezamos con los 4 primeros d√≠gitos en hexadecimal, es decir **6148**:

```bash
‚ùØ echo -e "\x61\x48"
aH
```

¬°¬°¬°Que raro que la __a__ y la __H__ est√©n invertidas!!!

Bien, pero ¬øde qu√© estamos hablando al final?

En inform√°tica, algunos datos, como los n√∫meros enteros, se pueden representar con varios bytes. ```El orden en que se organizan estos bytes``` en la memoria o en una comunicaci√≥n, ya sea por red o en memoria se denomina ```endianidad```. De la misma manera que algunos lenguajes humanos se escriben de izquierda a derecha, y otros se escriben de derecha a izquierda, existen dos alternativas a la organizaci√≥n de los bytes que representan un dato: la orientaci√≥n **big-endian** y orientaci√≥n **little-endian**.  
Tambi√©n se utilizan las expresiones byte order, byte order o byte sex.

[Endianness](https://es.wikipedia.org/wiki/Endianness) solo se refiere a datos estructurados en varios bytes, como n√∫meros enteros o caracteres Unicode, codificados en UTF-16 o UTF-32. Los datos de un solo byte, como los caracteres ASCII, no se ven afectados. (Definici√≥n copiada salvajemente de Wikipedia)

Para ver algo mas avanzado (en ingles) [Byte order marks (BOM)](https://unicodebook.readthedocs.io/unicode_encodings.html#byte-order-marks-bom) y profundizar en el tema.

La decodificaci√≥n de un car√°cter UTF-8 se realiza de la siguiente manera:

1. Inicialice un n√∫mero binario con todos los bits establecidos en 0. Se pueden necesitar hasta 21 bits.
2. Determine qu√© bits codifican el n√∫mero de car√°cter a partir del n√∫mero de octetos en la secuencia y la segunda columna de la tabla anterior (los bits marcados con x).
3. Distribuya los bits de la secuencia al n√∫mero binario, primero los bits de orden inferior del √∫ltimo octeto de la secuencia y siguiendo hacia la izquierda hasta que no queden x bits. El n√∫mero binario ahora es igual al n√∫mero de car√°cter.
 
ATENCI√ìN ! aparentemente UTF-8 ser√≠a **endianless**, algo que no sab√≠a, creo que la gente se confundi√≥ con BOM y el hecho de que no es obligatorio ponerlo. Lo mejor es que eches un vistazo aqu√≠ si realmente est√°s interesado: [RFC 3629 - UTF-8, a transformation format of ISO 10646](https://datatracker.ietf.org/doc/html/rfc3629#page-4)

Entonces, 
* ¬øqu√© es la endianidad?
* ¬øCu√°l es el tama√±o de un word?
* ¬øQu√© es la codificaci√≥n? ASCII, Unicode, UTF-8
* Decimal, Binario, Hexadecimal...

Creo que aprendimos o revisamos muchas cosas, y tal vez estar√≠a bien releer un poco e investigar para entender y asimilar mejor ;)

Admito que es un poco hacer fuerza bruta a las neuronas para llegar a un resultado que conocemos. La mayor√≠a de las computadoras modernas funcionan en little endian. Pero cuidado, ¬°el protocolo TCP lo hace en big-endian!  
Bueno, espero que est√° probado y entendido. Venga, para terminar os lo pongo al completo ;)

```bash
‚ùØ echo $'\x48\x61\x63\x6b\x65\x72\xc3\xb1\x6f\x6c'
Hacker√±ol
```

Este art√≠culo me vino a la mente mientras le√≠a este [Understanding pointers on Drew DeVault's blog](https://drewdevault.com/2016/05/28/Understanding-pointers.html) y hablando de cosas con amigos de hispagatos.

&nbsp;

Pero ¬ø qu√© es [Hacker√±ol](https://odysee.com/@Hackernol:7) ? 

> Hacker√±ol Para Hackers en Espa√±ol.

&nbsp;

[Amfora](https://github.com/makeworld-the-better-one/amfora) tip of the day :

**Space** 
* Opens bar at the bottom - type a URL, link number, search term.
* You can also type two dots (..) to go up a directory in the URL.
* Typing new:N will open link number N in a new tab instead of the current one.

Happy hacking ;)
